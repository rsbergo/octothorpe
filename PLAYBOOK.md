## COS 460/540 - Computer Networks
# Project 3: Octothorpe (#) The Game - Server

# Rafael de Souza Bergo

This project is written in **Java (JavaSE-17)** on **Windows**.

## How to compile

From the repository root folder:

Server:
```
javac src/server/Octothorpe.java -cp src -d bin
```

Client
```
javac src/client/Octothorpe.java -cp src -d bin
```

## How to run

From the repository root folder:

Server:
```
java -cp bin server.Octothorpe <port>
```

Client:
```
java -cp bin client.Octothorpe <host>
```

## My experience with this project

This was by far the most challenging project so far. I think that a considerable part of the chalenges came from my mindset though. In the first projects, I have implemented the server in a way that each client would have its own instance of the protocol running. This didn't work well for the game, since clients (players) share state. Changin the mindset and implementing it differently proved to be harder than I would have imagined.

I started by focusing on the server functionality implementation. The goal was to have a server that would be capable of receiving a connection and start a thread for the client connected. This thread would then start two additional threads: one for the game interactions and another for the game notifications. This worked well on its own, but became troublesome once interactions with the game started to grow, and specially when I started working on logging in.

I decided to take a different approach then, and focus on the game. The goal was to have a single player game, synchronous, running locally, but that provided the functionalities required. I ended up implementing the concepts of `Command` and `Result`: the game receives a `Command` from a player, processes it, and returns the result of processing the command. These are pretty much the concepts of `Request` and `Response`. Each command identifies the player who issued the command, the action to execute (`login`, `move`, `quit`, etc.), and the arguments for the action if any are needed. The result identifies the player who issued the command that generated the result, the result of the action using the same codes expected to be sent to the player's client, and contains a message with information about the result. The game uses `CommandHandler`s to process commands; this is an implementation very similar to the one I used for Project 2, and I really liked how easy it made to add functionality to the game.

With the core functionalities of the game working, I changed my focus to game notifications. Since these should be asynchronous, I decided to implement the Observer pattern: events are generated while commands are processed, and entities listening to those events react to them. This implementation lead to an `EventManager` that holds a list of `EventListeners` subscribed to listen to events of a specific `Subject`. When the game generates an event, the `EventManager` is responsible for notifying the `EventListeners` subscribed for the subject of the event generated. `EventHandlers` are responsible for processing the events generated by the game, consuming them. For asynchronous events, I decided to implement an `EventQueue`. The `EventQueue` implements the `EventListener` interface, so it can be notified of events. However, when notified, instead of processing the event immediately, the `EventQueue` queues the event to be processed. Processing events happens on a different thread that polls the `EventQueue` queue of events and processing them.

The next step was to implement the server and accept multiple connections. This part was not particularly hard, given the previous projects. The `GameServer` initiates an instance of the game and opens a `ServerSocket` bound to the port specified when the application is started. Then it starts listening for new connections and once a new connection is established, the `GameServer` creates a thread for a `PlayerHandler` and waits for the next connection. The `PlayerHandler` is responsible for the communication between the `GameServer` and the player's client application through the socket. This is done through `Requests` and `Responses`: the `PlayerHandler` receives a request through the socket and returns a `Response` with the result of the `Request` received. The `PlayerHandler` does some translation from a `Request` to a game `Command` and from a game `Result` to a `Response`. Even though `Request` and `Response` are very similar to the `Command` and `Result`, this design was appealing because it enables some flexiblity and I would expect that changes to the communication protocol could be implemented without requiring deep changes to the game mechanism.

The hardest challenge was to connect the `PlayerHandler` to the `EventHandlers`. For this game, the role of an `EventHandler` is essentially to generate a `Response` based on the event received and send it through the `PlayerHandler`'s socket. To be honest, I'm still not very happy with the way this connection is happening: there seems to be very tight coupling between components and the responsibilities of each entity start become less clear. This part of the code can definitely be improved. Each `Player` contains an `EventHandlerManager`. The `EventHandlerManager` contains a list of `EventHandlers` that have been installed for an event subject. `EventHandler`s implement the `EventListener` interface, so they can subscribe to the game's `EventManager`. Subscription to events is done once a player logs into the game. When a player logs out (`quit`), the `EventHandlers` are unsubscribed so they don't receive notifications anymore.

I also added a very basic logging mechanism. I really wanted to explore it, and since this application is handling multiple threads, I wanted to experiment with logging which thread is doing certain actions. I also wanted to add the concept of different levels for loggin: it is nice to see some things while debugging, but they may clutter loggin when not debugging. I really liked it and hope I can expand it in future projects.

The map files and player data file are expected to be found in the `res/` directory in the repository. The application expects an optional second parameter with the name of the map file (e.g. `cavern.map`). However, if no arguments are passed, it uses the default map provided.